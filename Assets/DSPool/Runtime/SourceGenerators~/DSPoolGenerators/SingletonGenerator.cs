using DSPoolGenerators.Constants;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using static DSPoolGenerators.Utilities;

namespace DSPoolGenerators;

[Generator]
public class SingletonGenerator : IIncrementalGenerator
{
    private readonly record struct TransformedInfo(string Name, string Namespace);

    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        var provider = context.SyntaxProvider
            .ForAttributeWithMetadataName(
                DSPoolSingletonAttributeConstants.IDENTIFIER,
                predicate: static (syntaxNode, _) => syntaxNode is ClassDeclarationSyntax,
                transform: static (context, _) => Transform(context));

        context.RegisterSourceOutput(provider, Generate);
    }

    private static TransformedInfo Transform(GeneratorAttributeSyntaxContext context)
    {
        var poolDeclaration = (ClassDeclarationSyntax)context.TargetNode;

        return new(poolDeclaration.Identifier.ToString(), GetNamespace(poolDeclaration));
    }

    private static void Generate(SourceProductionContext context, TransformedInfo transformedInfo)
    {
        GenerateSingleton(context, transformedInfo);
    }

    private static void GenerateSingleton(SourceProductionContext context, TransformedInfo transformedInfo)
    {
        var sourceCode = $@"// <auto-generated />
using System;
using UnityEngine;

namespace {transformedInfo.Namespace}
{{
    public partial class {transformedInfo.Name}
    {{
        private static {transformedInfo.Name} instance;
        public static {transformedInfo.Name} Instance => instance ??= new();

        public static void DestroyInstance() => instance = null;

#if UNITY_EDITOR
        [RuntimeInitializeOnLoadMethod(RuntimeInitializeLoadType.SubsystemRegistration)]
        public static void ClearOnLoad() => DestroyInstance();
#endif
    }}
}}
";

        context.AddSource($"{transformedInfo.Namespace}.{transformedInfo.Name}.Singleton.g.cs", sourceCode);
    }
}
